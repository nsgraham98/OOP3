package utilities;

import java.util.Comparator;

/**
 * Quick Sort is a divide-and-conquer algorithm with three steps:
 * - Choose a "pivot" element from the array (Uses median of 3 method to determine pivot)
 * - Partition and rearrange the array around the pivot so that all elements smaller than
 * 	 the pivot are to the left of the pivot, and all elements larger are to the right
 * - Recursively calls itself to perform the same operation on both partitioned sub-arrays
 * - The recursion ends when it reaches the base case, i.e. when there is only one element in the sub-array
 * 
 * Time Complexity:
 * - Average Case: O(n log n)
 * - Worst Case: O(n^2)
 * 		- Mitigated using median of 3 to choose pivot
 * 
 * Space Complexity: O(n) 
 * - Recursive implementation
 * 
 * To call them in the driver class
 * QuickSort.sort(
 * 
 * @author Nick, Shawn, Ahmad
 * @version 1.8
 */
public class QuickSort {
    
	
	// Public interface method to sort an array of objects using a provided comparator.
    public static <T> void sort(T[] arr, Comparator<T> comparator) {
        if (arr == null || arr.length <= 1) {
            return; // Already sorted
        }
        sort(arr, comparator, 0, arr.length - 1);
    }
    
    // Recursive sorting method that implements the QuickSort algorithm.
    private static <T> void sort(T[] arr, Comparator<T> comparator, int start, int end) {
        if (end <= start) return; // Base case
        
        int pivotIndex = partition(arr, start, end, comparator);
        sort(arr, comparator, start, pivotIndex - 1); // Sort left side
        sort(arr, comparator, pivotIndex + 1, end);   // Sort right side
    }
    
    private static <T> int partition(T[] arr, int low, int high, Comparator<T> comparator) {
        // Only use median-of-three if we have at least 3 elements
        if (high - low >= 2) {
            // Find median of low, middle, and high
            int mid = low + (high - low) / 2;
            
            // Sort low, mid, and high to find the median
            if (comparator.compare(arr[low], arr[mid]) > 0) {
                swap(arr, low, mid);
            }
            if (comparator.compare(arr[low], arr[high]) > 0) {
                swap(arr, low, high);
            }
            if (comparator.compare(arr[mid], arr[high]) > 0) {
                swap(arr, mid, high);
            }
            
            // Place the median (now at mid) as the pivot at high-1
            swap(arr, mid, high);
        }
        
        // Use the high element as pivot (either it's the median or we have fewer than 3 elements)
        T pivot = arr[high];
        
        // Index of smaller element
        int i = low - 1;
        
        // Traverse through all elements, compare each element with pivot
        for (int j = low; j < high; j++) {
            // If current element is greater than or equal to pivot (changed for descending order)
            if (comparator.compare(arr[j], pivot) >= 0) {
                i++;
                // Swap arr[i] and arr[j]
                swap(arr, i, j);
            }
        }
        
        // Swap arr[i+1] and arr[high] (or pivot)
        swap(arr, i + 1, high);
        
        return i + 1;
    }


    // method to swap two elements in an array.

    private static <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

